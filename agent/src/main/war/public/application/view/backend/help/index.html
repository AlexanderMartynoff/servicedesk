<h1>Справка</h1>

Если бы мы считали, как раньше, что str – это объект, мы бы удивились, почему он не запомнил в себе новое свойство test. Но теперь мы знаем, что при обращении к примитиву как к объекту, он временно оборачивается в объект типа String. Но после выполнения операции эта обёртка исчезает, а вместе с ней и новое свойство test. Вот и всё, никакой магии.

На самом деле, забегая наперёд, во время оборачивания примитива в объект, выстраивается целая цепочка наследования (как это организовано мы поговорим позже), но по сути получается такая вот «матрёшка»:

Object(Number(примитив)). Родителем любого объекта в JS, так или иначе, будет Object. При вызове свойства в объекте поиск проходит по всей этой «матрёшке» пока не найдёт в одном из объектов это свойство или вернёт undefined или если искали метод, то выбросит исключение. Таким образом, у примитива также доступны свойства объекта Object. Как работает прототипное наследование и о его тонкостях мы поговорим во второй статье.

Для интриги над второй статьёй, которую я хочу выпустить, расскажу про ещё один момент связанный с функциями конструкторами — это преобразование типов. JS — это не строго типизированный язык. Это значит, что в момент объявления переменной мы не обязаны указать какого она типа, и более того во время работы программы в эту переменную можно ложить данные абсолютного любого типа. А так же мы можем использовать, например, строковые переменные в математических действиях или наоборот, числа в операции конкатенации.



